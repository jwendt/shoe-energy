function [s v m] = RemoveSample(sensors, ...
                                s_0, ...
                                v_0, ...
                                K, ...
                                data, ...
                                step_starts, ...
                                step_ends, ...
                                threshold_percent, ...
                                dlds, ...
                                amp, ...
                                lateral, ...
                                heeltoe);
  LoadConstants;

  sensor_list = find(sensors);

  [num_samples num_sensors] = size(s_0);
  s = logical(ones(num_samples*num_sensors, num_samples, num_sensors));
  m = zeros(num_samples*num_sensors, 4);

  samples_removed = 0;
  for j = 1:num_samples
    for k = 1:num_sensors
      % ignore sample if it's already in the removed list
      if ~s_0(j,k)
        continue;
      end
      % ignore sample if it's not a valid sample
      if ~v_0(j,k)
        continue;
      end

      % try removing this sample
      samples_removed = samples_removed + 1;
      s(samples_removed,:,:) = s_0;
      s(samples_removed,j,k) = 0;

      % augment the data matrix for this sample
      for step_i = length(step_starts)
        for sample_i = step_starts(step_i)+find(~s(samples_removed,k));
          if sample_i <= step_ends(step_i)
            data(sensor_list(k),sample_i) = NaN;
          end
        end
      end

    % get new metrics and compute prediction errors
    [nada1 ...
     nada2 ...
     nada3 ...
     nada4 ...
     dlds_at_sensor ...
     amp_at_sensor ...
     land_at_sensor] = GetMetricsFromSingleDataSource(data, ...
                                                      step_starts, ...
                                                      step_ends, ...
                                                      threshold_percent);
    % compute prediction errors
    dlds_errors = ComputeLinearPredictionError(dlds, ...
        dlds_at_sensor(:,sensors), dlds, ...
        dlds_at_sensor(:,sensors));
    amp_errors = ComputeLinearPredictionError(amp, ...
        amp_at_sensor(:,sensors), amp, ...
        amp_at_sensor(:,sensors));
    lateral_errors = ComputeLinearPredictionError(lateral, ...
        amp_at_sensor(:,sensors), lateral, ...
        amp_at_sensor(:,sensors));
    heeltoe_errors = ComputeLinearPredictionError(heeltoe, ...
        land_at_sensor(:,sensors), heeltoe, ...
        land_at_sensor(:,sensors));

    % combine errors
    m(samples_removed,1) = CombineErrors(dlds_errors);
    m(samples_removed,2) = CombineErrors(amp_errors);
    m(samples_removed,3) = CombineErrors(lateral_errors);
    m(samples_removed,4) = CombineErrors(heeltoe_errors);
  end

  % strip off trailing predictions from initialization
  m = m(1:samples_removed,:);

  % rank predictors
  [ranked_indices, thresholds_reached] = ...
      RankByThresholdDirection(m, ...
                               config.ranking_error_thresholds, ...
                               config.ranking_error_directions);

  % keep at most top K predictors
  if samples_removed > K
    ranked_indices = ranked_indices(1:K);
  end
  m = m(ranked_indices,:);
  s = s(ranked_indices,:,:);

  % invalidate samples that are predictors
  v = logical(ones(length(ranked_indices), num_samples, num_sensors));
  for i = 1:length(ranked_indices)
    v(i,:,:) = v_0;
    v(i,~s(i,:)) = 0;
  end
