function Y = RunPipeline(max_sensors, K1, K2, input, left_right, output, greed_choice)
% RunPipeline(MAX_SENSORS, K1, K2, INPUT, LR, OUTPUT, CHOICE)
%   Runs the shoe sensor optimization.
%
% Parameters:
%
%   MAX_SENSORS   Maximum number of sensor groupings to create (originally
%                 called num_cica)
%
%   K1       ?? Number of new predictor sets to return for each call
%            Choose only the top K1 sensor groupings from those created by
%            adding a new sensor to an existing grouping
%
%   K2       ?? Number of new predictor sets to return for each step
%            Choose only the top K2 sensor groupings from all those K1*K2
%            sensor groupings that were created at each setp
%
%   INPUT    A cell array of paths to *.mat files with left and right data
%            points
%
%   LR       A cell array of size 1 or 2 with the values 'left' and/or
%            'right'
%
%   OUTPUT   A path to the output folder
%
%   CHOICE   Explained by GetIndices functoin. Choices are 'greedy', 'rep', and
%            'greedy-rep'

%%%%%%%%%%%%%%%%%%
% Configurations %
%%%%%%%%%%%%%%%%%%
warning('off');

%input = {'data/S1.mat';
%         'data/S2.mat';
%         'data/S3.mat';
%         'data/S4.mat';
%         'data/S5.mat';};

% The following masks are used by GetSensorGroupingsFromPedar to return the indices of
% those sensors that match the given mask shapes. Note that
% GetSensorGroupingsFromPedar automagically produces sensor groupings of size 1
% so we do not need to include those in the masks cell array
masks{1} = [1 1];

masks{2} = [1;
            1];

masks{3} = [1 1;
            1 1];

masks{4} = [1 1 1 1;
            1 1 1 1];

masks{5} = [1 1;
            1 1;
            1 1;
            1 1];

masks{6} = [1 1 0 0;
            1 1 0 0;
            1 1 1 1;
            1 1 1 1];

masks{7} = rot90(masks{6});

masks{8} = rot90(masks{7});

masks{9} = rot90(masks{8});

[groupings_list...
 groupings_matrix...
 outer_side_indices...
 inner_side_indices...
 heel_side_indices...
 toe_side_indices] = GetSensorGroupingsFromPedar(masks{:});

[dlds...
 amp...
 lateral...
 heeltoe...
 dlds_at_sensor...
 amp_at_sensor...
 land_at_sensor...
 step_starts...
 step_ends...
 test_dlds...
 test_amp...
 test_lateral...
 test_heeltoe...
 test_dlds_at_sensor...
 test_amp_at_sensor...
 test_land_at_sensor...
 test_step_starts...
 test_step_ends...
 train_step_starts...
 train_step_ends...
 train_data] = GetMetrics(input,...
                          left_right,...
                          groupings_list,...
                          outer_side_indices,...
                          inner_side_indices,...
                          heel_side_indices,...
                          toe_side_indices);

% Now we have our metrics and our *_at_sensor matrices for all sensors and
% sensor groupings... create pruned graph for CICA
fprintf('Build prediction graph\n');
prediction_graph = BuildPredictionDiffGraph(dlds, ...
                                            amp, ...
                                            lateral, ...
                                            heeltoe, ...
                                            dlds_at_sensor, ...
                                            amp_at_sensor, ...
                                            land_at_sensor);

fprintf('Calculate difference thresholds\n');
[dlds_threshold ...
 amp_threshold ...
 lateral_threshold ...
 heeltoe_threshold] = CalculateDiffThresholds(prediction_graph, ...
                                              0, 0, 0, 0);

fprintf('Prune graph\n');
g = PruneGraph(prediction_graph, ...
               groupings_matrix, ...
               dlds_threshold, ...
               amp_threshold, ...
               lateral_threshold, ...
               heeltoe_threshold);

fprintf('Perform a variant of CICA to select best sensor groupings\n');
[s v m] = SelectSensors(max_sensors,...
                        g,...
                        K1,...
                        K2,...
                        dlds,...
                        amp,...
                        lateral,...
                        heeltoe,...
                        dlds_at_sensor,...
                        amp_at_sensor,...
                        land_at_sensor,...
                        greed_choice);

fprintf(sprintf('Saving results to %s\n', output));
PrintResults(output,...
             s,...
             groupings_list,...
             m,...
             dlds,...
             amp,...
             lateral,...
             heeltoe,...
             dlds_at_sensor,...
             amp_at_sensor,...
             land_at_sensor,...
             test_dlds,...
             test_amp,...
             test_lateral,...
             test_heeltoe,...
             test_dlds_at_sensor,...
             test_amp_at_sensor,...
             test_land_at_sensor);

save(sprintf('%s/results.mat',output));

